#!/bin/bash

# TODO
#   `!p python code...`
#   `date +%d`
#   perl -e '$s=q(test code long ${0}); $s =~ s{\$\{(.+?)\}}{ (0+$1) * 99; eval($code) }ge; print $s;'
#   fix space query
#   while do continue
#   autocomplete from fzf?
#     join query + docker + kube etc..

show_help() {
  echo "Usage: $0 <filetype>"
}

if [ -z "$1" ]; then
  show_help
  exit 1
fi

cd "$HOME/dots/snips" || exit 1

ft=$1
fp=$2
snips=("all.snips")
[ -r "$ft.snips" ] && snips+=("$ft.snips")

case $ft in
  typescriptreact) snips+=("typescript.snips") ;;
  typescript) snips+=("javascript.snips") ;;
  javascript)
    case $fp in
      */javascript/controllers/* ) snips+=("rails/stimulus.snips") ;;
    esac ;;
  zsh|bash) snips+=("sh.snips") ;;
  terraform|hcl) snips+=("terraform.snips") ;;
  toml)
    case $fp in
      *mise.toml       ) snips+=("mise.snips") ;;
      *mise.*.toml       ) snips+=("mise.snips") ;;
      *mise/config.toml) snips+=("mise.snips") ;;
    esac ;;
  yaml)
    case $fp in
      *deployment/*      ) snips+=("kube.snips") ;;
      *k8s/*             ) snips+=("kube.snips") ;;
      *kubernetes/*      ) snips+=("kube.snips") ;;
      *manifests/*       ) snips+=("kube.snips") ;;
      *values.yaml       ) snips+=("helm.snips") ;;
      *docker-compose.y* ) snips+=("docker_compose.snips") ;;
      *compose.y*        ) snips+=("docker_compose.snips") ;;
      *.github/workflows*) snips+=("github_workflow.snips") ;;
      *.github/actions*  ) snips+=("github_action.snips") ;;
      *helmfile.d/*      ) snips+=("helmfile.snips") ;;
      */templates/*      ) snips+=("helm_chart.snips") ;;
      */fixtures/*       ) snips+=("rails/fixture.snips") ;;
    esac ;;
  ruby)
    case $fp in
      *app/admin/*      ) snips+=("rails/admin.snips") ;;
      *app/*            ) snips+=("rails/app.snips") ;;
      *config/*         ) snips+=("rails/config.snips") ;;
      *db/migrate/*     ) snips+=("rails/migrate.snips") ;;
      *test/*           ) snips+=("rails/minitest.snips") ;;
      *spec/*           ) snips+=("rails/minitest.snips") ;;
      *Rakefile         ) snips+=("rake.snips") ;;
      *Vagrantfile      ) snips+=("vagrant.snips") ;;
    esac ;;
  eruby.yaml)
    case $fp in
      *test/fixtures/*) snips+=("rails/fixture.snips") ;;
      *spec/fixtures/*) snips+=("rails/fixture.snips") ;;
    esac ;;
  eruby)
    case $fp in
      *app/views/*) snips+=("rails/app.snips") ;;
    esac ;;
esac

# resolve_imports: snips 배열의 파일들에서 extends 해석
resolve_imports() {
  local visited=""
  local queue=("${snips[@]}")
  local result=()
  local file import imported

  while [ ${#queue[@]} -gt 0 ]; do
    file="${queue[0]}"
    queue=("${queue[@]:1}")

    [[ "$visited" == *"|$file|"* ]] && continue
    visited+="|$file|"
    result+=("$file")

    # extends 라인 파싱 (첫 snippet 정의 전까지만)
    while IFS= read -r import; do
      if [[ "$import" == */ ]]; then
        # 디렉토리인 경우 - 하위 모든 .snips 추가
        for f in "$import"*.snips; do
          [ -r "$f" ] && queue+=("$f")
        done
      else
        imported="${import}.snips"
        [ -r "$imported" ] && queue+=("$imported")
      fi
    done < <(perl -ne 'last if /^snippet /; print "$1\n" if /^extends\s+(.+)/' "$file" 2>/dev/null)
  done

  snips=("${result[@]}")
}

resolve_imports

tmpfile=$(mktemp)
trap "rm -f $tmpfile" EXIT

rg --with-filename --color=never '^snippet ' ${snips[@]} \
  | perl -ne 's/^(?<f>.+?):snippet (?<n>.+?) "(?<c>.*)"//; printf qq{%-30s\t\033[33m%-20s\033[0m\t%s\n}, $+{n}, $+{c}, $+{f}' \
  | sort \
  | fzf --delimiter "\t" --with-nth='1,2' --select-1 --height '~50%' \
        --preview 'perl -ne "\$a=sprintf {1}; print if /^snippet \$a /../endsnippet/ and not /^snippet|endsnippet/" {3} \
          | bat --plain --color always --language ruby' \
        --preview-window 'bottom:nowrap' \
        --bind 'ctrl-e:become(nvim {3})' \
        --bind 'enter:become(perl -ne "\$a=sprintf {1}; print if /^snippet \$a\b/../endsnippet/ and not /^snippet|endsnippet/" {3} > '"$tmpfile"')'

if [ ! -s "$tmpfile" ]; then
  exit 1
fi

replace_words=$(perl -nle 'print "$1" if /##{(.+?)}/' "$tmpfile" | sort -r | perl -nle '/(^\d+)/; print unless $seen{$1}++' | sort)

if [ -n "$replace_words" ]; then
  echo "$replace_words" | while IFS=$'\n' read -r line; do
    rnum=$(echo "$line" | perl -ne '/(\d+):?(.+)?/; print $1')
    rdefault=$(echo "$line" | perl -ne '/(\d+):?(.+)?/; print $2')

    input_word=$(echo '' | fzf --delimiter "\t" --query "$rdefault" \
      --header "$line" \
      --preview-window 'bottom:nowrap:99%' \
      --preview "perl -pe '\$a=q({q}); s;\##\{$rnum.*?};\$a;g' $tmpfile | bat" \
      --bind "ctrl-c:become(echo $rdefault)" \
      --bind 'enter:become(echo {q})')

    if [ -z "$input_word" ]; then
      input_word=$rdefault
    fi
    perl -i -pe "s;\##\{$rnum.*?};$input_word;g" "$tmpfile"
  done
fi

cat "$tmpfile"
