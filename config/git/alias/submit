#!/bin/bash
# Submit current branch: sync + push + create PR
# Usage:
#   git submit         # PR creation + CI watch
#   git submit -d      # Draft PR
#   git submit -n      # Skip pre-push hooks
#   git submit --no-wait  # Skip CI watch
#   git submit --dry   # Show what would happen (no push/PR)
#   git submit --diff  # Show diff against upstream
#   git submit --help  # Show this help
#
# Uses GIT_UPSTREAM env var (default: origin/main)

set -e

# Colors
CYAN='\033[1;36m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

git rev-parse --git-dir > /dev/null 2>&1 || { echo "Not a git repository"; exit 1; }

# Parse arguments
draft_flag=""
dry_run=false
show_diff=false
no_verify=""
no_wait=false

for arg in "$@"; do
  case "$arg" in
    -d|--draft) draft_flag="--draft" ;;
    -n|--no-verify) no_verify="--no-verify" ;;
    --no-wait) no_wait=true ;;
    --dry) dry_run=true ;;
    --diff) show_diff=true ;;
    -h|--help)
      sed -n '2,11p' "$0" | sed 's/^# //' | sed 's/^#//'
      exit 0
      ;;
  esac
done

upstream="${GIT_UPSTREAM:-origin/main}"
remote="${upstream%%/*}"
branch="${upstream#*/}"
current=$(git branch --show-current)

if [ -z "$current" ]; then
  echo "Error: Not on a branch (detached HEAD)"
  exit 1
fi

if [ "$current" = "$branch" ] || [ "$current" = "main" ] || [ "$current" = "master" ]; then
  echo "Error: Cannot submit from $current branch"
  exit 1
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD -- 2>/dev/null; then
  echo "Error: You have uncommitted changes"
  echo "Please commit or stash them before submitting"
  git status --short
  exit 1
fi

# Check if there are commits to submit
commits=$(git rev-list --count "$upstream".."$current" 2>/dev/null || echo "0")
if [ "$commits" = "0" ]; then
  echo "Error: No commits to submit (branch is up to date with $upstream)"
  exit 1
fi

echo "=== Submitting: $current ($commits commit(s)) ==="

if [ "$show_diff" = true ]; then
  git diff "$upstream"..HEAD
  exit 0
fi

if [ "$dry_run" = true ]; then
  echo "[dry-run] Would sync with $upstream"
  echo "[dry-run] Would push to origin/$current"
  echo "[dry-run] Would create PR to $branch"
  echo ""
  echo "Commits to submit:"
  git log --oneline --graph --decorate "$upstream"^.."$current"
  exit 0
fi

# Check if PR already exists and its state
pr_state=$(gh pr view --json state -q '.state' 2>/dev/null || echo "")
if [ "$pr_state" = "MERGED" ]; then
  # Check for orphaned commits (commits added after merge)
  orphaned=$(git rev-list --count "$upstream".."$current" 2>/dev/null || echo "0")
  if [ "$orphaned" -gt 0 ]; then
    echo "Error: PR was merged, but you have $orphaned new commit(s)"
    echo ""
    echo "To rescue these commits to a new branch:"
    echo "  git begin --rescue"
  else
    echo "Error: PR for this branch has already been merged"
    echo "Start a new branch with: git begin"
  fi
  exit 1
fi
pr_exists=false
if [ -n "$pr_state" ]; then
  pr_exists=true
fi

# Step 1: Sync with upstream
echo ""
echo -e "${CYAN}==> Step 1/3: Syncing with $upstream...${NC}"
if ! git fetch "$remote" "$branch" 2>&1; then
  echo ""
  echo "Hint: Set GIT_UPSTREAM in .mise.local.toml if using a different upstream:"
  echo '  [env]'
  echo '  GIT_UPSTREAM = "up/main"  # or "origin/master"'
  exit 1
fi
git rebase "$upstream"

# Step 2: Push to origin
echo ""
echo -e "${CYAN}==> Step 2/3: Pushing to origin...${NC}"
git push -u --force-with-lease $no_verify origin HEAD

# Step 3: Create or update PR
echo ""
echo "Commits to submit:"
git log --oneline --graph --decorate "$upstream"^.."$current"
echo ""

if [ "$pr_exists" = true ]; then
  echo -e "${CYAN}==> Step 3/3: PR already exists, opening...${NC}"
  gh pr view --web
else
  echo -e "${CYAN}==> Step 3/3: Creating PR...${NC}"
  gh pr create --base "$branch" $draft_flag
  gh pr view --web
fi

echo ""
echo -e "${GREEN}Submitted: $current${NC}"

# Wait for CI (unless --no-wait)
if [ "$no_wait" = false ]; then
  echo ""
  echo -e "${CYAN}Waiting for CI...${NC} (Ctrl+C to skip)"
  echo ""

  # Wait a moment for CI to start
  sleep 3

  gh pr checks --watch --fail-fast
  exit_code=$?

  if [ $exit_code -ne 0 ]; then
    echo ""
    echo -e "${YELLOW}CI failed${NC}"
    echo ""
    echo "Options:"
    echo "  git ci          # Interactive CI status"
    echo "  git ci --rerun  # Rerun failed jobs"
  else
    echo ""
    echo -e "${GREEN}CI passed${NC}"
  fi
fi
