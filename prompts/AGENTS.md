# FIRST: 세션 시작 프로토콜

**사용자의 첫 번째 메시지에 응답하기 전에, 반드시 아래를 실행한다.**
첫 번째 응답의 첫 번째 행동이 이 프로토콜이어야 한다. 예외 없음.

1. **MEMORY.md 읽기** — 프로젝트 컨텍스트, 이전 학습 복원 (시스템 프롬프트에 이미 포함되어 있으면 생략)
2. **WIP 확인** — `memory/wip.md` 있으면 읽어서 진행 중 작업 복원
3. **TaskList 확인** — 진행 중/미완료 task 파악
4. **git status** — 작업 디렉토리의 마지막 작업 흔적, 수정 파일 확인
5. **사용자에게 상태 요약** — 위 결과를 한 문단으로 보고 후, 이어서 할지 새로 시작할지 질문

**이 프로토콜을 건너뛰고 사용자 요청에 바로 답하지 않는다.**

---

# 대원칙: 쪼개서 해결한다

**문제를 정의하고, 쪼개고, 해결한다.**

## 1. 이해한다

- 무엇을 해결해야 하는지 파악한다
- 모호하면 질문한다
- 코드를 읽어 현재 상태를 파악한 뒤 작업한다

## 2. 계획한다

- **작업 계획을 먼저 정리**한다 — 무엇을, 어떤 순서로, 어떤 방식으로
- **방식**: 직접 할지, subagent에 맡길지, 팀을 꾸릴지, skill을 쓸지
- **Skill 매핑**: system-reminder의 available skills 목록을 확인하고, 각 task에 적용할 skill을 선정하여 계획에 `/skill-name` 형태로 명시한다
- **병렬화**: 의존성 없는 태스크를 식별하고 subagent/team으로 동시 실행한다
- **블로킹 최소화**: 구현 작업(파일 생성/수정/빌드/테스트)은 백그라운드 subagent 위임을 고려한다
- **검증**: 각 단위를 어떻게 검증할지 미리 정한다 (테스트, 스크린샷, 예상 출력)
- 3개 이상이면 TaskCreate로 목록화한다
- 계획 없이 코드부터 작성하지 않는다

## 3. 해결한다

- 독립 태스크는 **병렬로** 실행한다 (subagent 동시 호출 / team 분배)
- 의존성 태스크만 순서대로 완료 → 검증 → 다음
- 탐색과 검증은 subagent에 위임하여 **메인 컨텍스트를 보호**한다
- 막히면 근본 원인을 추적한다
- **작업 단위 완료 시 즉시 커밋**: 질문 없이 바로 커밋한다

---

## Bash

- 독립 명령은 병렬 호출로 분리, `&&`/`|` 체이닝 금지

---

## Memory

built-in auto memory 규칙을 따르되, 추가 규칙:

| 계층 | 대상 | 수명 |
|------|------|------|
| MEMORY.md | 확정 패턴, 아키텍처, 사용자 선호 | 영속 (200줄 이내) |
| topic file | 상세 참조 (debugging.md 등) | 영속 (on-demand Read) |
| wip.md | 컨텍스트 보존용 작업 상태 | 휘발 (작업 완료 시 삭제) |

- `wip.md`는 compaction 대비 전용. 작업 완료 시 즉시 삭제한다
- 검증된 학습은 MEMORY.md 또는 topic file에 직접 기록 (wip.md 경유 불필요)

---

## Compaction

When compacting, always preserve: **TaskList 상태, 현재 진행 중인 task ID, 수정한 파일 목록**.

**Flush** (`/compact` 전에 가능하면 실행): WIP 상태를 `memory/wip.md`에 기록한다.
- 현재 작업 컨텍스트, 미완료 사항, 핵심 결정사항

컨텍스트 압축 후:

1. **wip.md 읽기** — 이전 작업 상태 복원
2. **TaskList 확인** — 어디까지 했는지 파악
3. **적합한 Skill 호출** — 작업에 필요한 컨텍스트를 skill이 복원
4. **이어서 해결** — 다음 미완료 task부터 재개
