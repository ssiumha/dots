snippet docker_host_url ""
host.docker.internal
endsnippet

snippet docker_ip "need ports or --publish"
DOCKER_IP=$(docker inspect -f "{{ .NetworkSettings.Gateway }}" "${MYSQL_DOCKER_NAME}")
DOCKER_PORT=$(docker inspect -f "{{(index (index .NetworkSettings.Ports \"3306/tcp\") 0).HostPort}}" "${MYSQL_DOCKER_NAME}")
endsnippet

snippet docker_ip_jq "need ports or --publish"
docker inspect compose-mysql | \
  jq -r ".[] | .NetworkSettings | [ .Networks.compose_network.Gateway, .Ports.\"${target_port}/tcp\"[0].HostPort ] | join(\":\")"
endsnippet

snippet docker_whoami ""
docker run -p 80:80 traefik/whoami
endsnippet

snippet build_using_tar "over pipeline"
tar -X .dockerignore -czh . \
  | docker buildx build -f Dockerfile -
endsnippet

snippet docker_go ""
go() {
  docker run --rm -v "$(pwd):/app" -w /app golang:latest go "$@"
}
endsnippet

snippet docker_certbot "manual register TXT"
# ./volumes/certbot/live/example.com/
#   - cert.pem
#   - privkey.pem
#   - fullchain.pem
#   - chain.pem
docker run --rm -it \
  -v ./volumes/certbot/:/etc/letsencrypt \
  -v ./volumes/certbot/lib:/var/lib/letsencrypt \
  certbot/certbot certonly \
    --manual --preferred-challenges dns \
    -d example.com -d '*.example.com' \
    -m you@example.com --agree-tos --no-eff-email
endsnippet

snippet caddy_test_cert ""
# can create certificates with mkcert
# CAROOT="$(pwd)/pki" mkcert -ecdsa \
#   -cert-file server.crt -key-file server.key \
#   "api.internal.local" "*.svc.cluster.local" 10.0.0.10 ::1
echo ':443 {
  root * /site
  file_server browse
  tls /certs/server.crt /certs/server.key
}' | docker run --rm -i -p 8443:443 \
  -v "$PWD":/site:ro \
  -v "$PWD":/certs:ro \
  caddy:2 caddy run --config - --adapter caddyfile

# testing
curl --cacert pki/rootCA.pem \
  --resolve api.internal.local:8443:127.0.0.1 \
  https://api.internal.local:8443/
endsnippet
